{
  # TODO how should this module be connected to the other sops one?
  perSystem.canivete.opentofu = {
    sharedPlugins = ["opentofu/random"];
    sharedModules.sops = {
      config,
      lib,
      pkgs,
      ...
    }: let
      inherit (lib) concatMapStrings getExe mkOption mkIf replaceStrings toUpper types flip mapAttrs getAttr mapAttrs' nameValuePair concatStringsSep mapAttrsToList;
      inherit (types) attrsOf submodule str listOf anything;
      inherit (config.canivete) sops;
    in {
      options.canivete = {
        passwords = mkOption {
          type = attrsOf (attrsOf anything);
          default = {};
          description = "Terraform random_password configs";
        };
        sops = mkOption {
          default = {};
          description = "Secrets generated by Terraform to store in SOPS";
          type = attrsOf (submodule ({
            config,
            name,
            ...
          }: {
            options = {
              value = mkOption {
                type = str;
                description = "Terraform attribute reference with SOPS secret contents";
              };
              path = mkOption {
                type = listOf str;
                description = "Path in the default encrypted SOPS file to drop the secret";
              };
              env = mkOption {
                type = str;
                default = replaceStrings ["." "-"] ["__" "_"] (toUpper name);
                description = "Name of variable in a shell environment";
              };
              command = mkOption {
                type = str;
                description = "Command to save value in SOPS, running in the project root directory";
                default = let
                  indexPath = concatMapStrings (segment: "[\"${segment}\"]") config.path;
                  # TODO why does this create a weird syntax highlighting issue in the file?
                  envValue = "\\\"\$${config.env}\\\"";
                in "${getExe pkgs.sops} set .canivete/sops/default.yaml '${indexPath}' \"${envValue}\"";
              };
            };
          }));
        };
      };
      config = {
        canivete.sops = flip mapAttrs config.canivete.passwords (name: _: {
          path = ["passwords" name];
          value = "\${ random_password.${name}.result }";
        });
        resource = mkIf (sops != {}) {
          random_password = config.canivete.passwords;
          null_resource.sops = {
            triggers = mapAttrs (_: getAttr "value") sops;
            provisioner.local-exec.environment = mapAttrs' (_: cfg: nameValuePair cfg.env cfg.value) sops;
            provisioner.local-exec.command = ''
              cd "$(${getExe pkgs.git} rev-parse --show-toplevel)"
              ${concatStringsSep "\n" (mapAttrsToList (_: getAttr "command") sops)}
            '';
          };
          null_resource.kubernetes.depends_on = ["null_resource.sops"];
          # Keep this for now, but really the SOPS method is more general (maybe best for secrets though...)
          null_resource.kubernetes.provisioner.local-exec.environment = mapAttrs' (_: cfg: nameValuePair cfg.env cfg.value) sops;
        };
        # TODO why does this method below fail with "option resource" defined multiple times?
        # modules.sops.resource = mkMerge [
        #   {
        #     null_resource.sops.provisioner.local-exec.command = ''
        #       cd "$(${getExe pkgs.git} rev-parse --show-toplevel)"
        #       ${concatStringsSep "\n" (mapAttrsToList (_: getAttr "command") sops)}
        #     '';
        #     null_resource.kubernetes.depends_on = ["sops"];
        #   }
        #   (flip mapAttrsToList config.canivete.passwords (name: cfg: {random_password.${name} = cfg;}))
        #   (flip mapAttrsToList config.canivete.sops (name: cfg: {
        #     null_resource.sops.triggers.${name} = cfg.value;
        #     null_resource.sops.provisioner.local-exec.environment.${cfg.env} = cfg.value;
        #     # Keep this for now, but really the SOPS method is more general (maybe best for secrets though...)
        #     null_resource.kubernetes.provisioner.local-exec.environment.${cfg.env} = cfg.value;
        #   }))
        # ];
      };
    };
  };
}
